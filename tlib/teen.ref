TEEN.LIB v0.37a TEEN.REF                                            2001/ 4/24
------------------------------------------------------------------------------

◆共通事項◆

  ・多くのファンクションは再入できず、再入しようとした場合にエラーを返します。
  ・一部のファンクションは、割り込み禁止状態で呼び出すことができません。「割
    り込み禁止状態」には、CPU の割り込み許可フラグが OFF になっている場合の
    他に、ハードウェア割り込みによって呼び出されたルーチンが割込みコントロー
    ラに「割り込み終了」を通知していない場合も含みます。
  ・一部のファンクションは、ハードウェア割り込みルーチンから呼び出すことがで
    きません。
  ・CPU の割り込み許可フラグを OFF (CLI)の状態でファンクションを呼び出しても、
    ファンクションの実行中に割り込み許可フラグが ON (STI) の状態になることが
    あります。
  ・teen_available を呼び出すまで、ほとんどのファンクションが使用できません。


===============================================================================
■　ＴＥＥＮ一般　■ (teen.h)
===============================================================================
【機　能】  TEEN 常駐確認およびライブラリ初期化

【書　式】  int  teen_available(void);

【戻り値】  0     : 常駐していない
            0以外 : 常駐している

【詳　説】  TEEN が常駐しているかどうかを返す。また、TEEN API の割込み番号を取
            得して内部変数に格納し、以下の関数が TEEN API を利用できるようにす
            る。
              名前が dialup_,tcp_,udp_,indicate_,ip_,icmp_ で始まる関数
              名前が inet_ で始まる関数(inet_aton,inet_ntoa除く)
              getipaddress
              teen_version,teen_machine,teen_mtime
            プログラム実行開始後、上記の関数の使用に先立って teen_available を
            呼び出さなければならない。ただし、一度呼び出せば十分である。
            teen_available が 0 を返した場合、上記の関数は利用できない。

-------------------------------------------------------------------------------
【機　能】  TEEN バージョン取得

【書　式】  uint teen_version(void);

【戻り値】  下位 8 bit : バージョン整数部
            上位 8 bit : バージョン少数部

【詳　説】  常駐している TEEN のバージョンを返す。

-------------------------------------------------------------------------------
【機　能】  機種種別・OS 種別取得

【書　式】  uint teen_machine(void);

【戻り値】  BIT0-3 : 機種コード
            BIT4-7 : 機種サブコード

		     機種コード	                機種サブコード
                     0     .. PC-88VA           1..VA1
                                                2..VA2/3
                                                3..VA1+91
                     1     .. PC-9801/9821      不定
		     4     .. FM-R              不定
		     5     .. FM-TOWNS          不定
		     8     .. IBM-PC            不定
                     その他.. 予約              予約

            BIT8-15 : OS コード
                      BIT8     : 1.PC-Engine                0.非PC-Engine
                      BIT9     : 1.MS-DOS                   0.非MS-DOS
                      BIT10    : 1.MS-DOSファンクション互換 0.非互換
                      BIT11-15 : 不定

【詳　説】  機種と OS の種類を返す。
            OS コードとして、具体的には以下を返す。
            BIT8-10(2進表記)
              110. MS-DOS
              001. PC-Engine
              101. PC-Engine+MSE

            アプリケーションが MS-DOS 特有の（PC-Engine にはない）DOS ファンク
            ション（INT 21h）を利用する場合は OS コードの BIT10 を検査すること
            により、MS-DOS のワークエリアを参照する場合は OS コードの BIT9 を
            検査することにより、誤動作を防ぐことができる。

-------------------------------------------------------------------------------
【機　能】  PPP 接続確立

【書　式】  int  dialup_open(int n);

            int n;          常に 0 を指定する。

【戻り値】   0 : 接続完了
             2 : 他のファンクションの処理を実行中で接続できない
             6 : ユーザーの指示による作業の中断
             7 : 電話が切れた
             8 : AT コマンドエラー
             9 : 相手が電話に出ない
            10 : 話し中
            11 : ダイヤルトーンが検出できない
            12 : ログイン名またはパスワードが不正
            13 : タイムアウト

【詳　説】  PPP 接続を確立する。接続の完了または失敗を待って戻る。接続が完了し
            た場合は 0 を、接続に失敗した場合はその原因を返す。
            ESC キーによって接続作業を中断することができる。
            接続に失敗した場合でも dialup_close を呼び出す必要はない。
            ハードウェア割り込みルーチンからの呼び出し不可。

-------------------------------------------------------------------------------
【機　能】  PPP 接続切断

【書　式】  int  dialup_close(void);

【戻り値】   0 : 接続完了
             2 : 他のファンクションの処理を実行中で切断できない

【詳　説】  PPP接続を切断する。切断の完了を待って戻る。
            ESCキーで処理を中断できる。
            ハードウェア割り込みルーチンからの呼び出し不可。

-------------------------------------------------------------------------------
【機　能】  文字列 -> IP アドレス変換

【書　式】  IDWORD inet_aton(char *str);

            char *str;      xxx.yyy.zzz.www の形式の文字列へのポインタ

【戻り値】  IP アドレス

【詳　説】  文字列が IP アドレスとして不適当なものであるときは、0(=0.0.0.0) を
            返す。

-------------------------------------------------------------------------------
【機　能】  IP アドレス -> 文字列変換

【書　式】  char *inet_ntoa(IDWORD addr);

            IDWORD addr;    IP アドレス

【戻り値】  IP アドレスを表す文字列

-------------------------------------------------------------------------------



===============================================================================
■　ネームサービス　■ (ns.h)
===============================================================================
【機　能】  ホスト名 -> IP アドレス変換

【書　式】  IDWORD getipaddress(char far *name);

            char far *name; ホスト名文字列へのポインタ

【戻り値】  エラー   : 0
            正常終了 : IP アドレス

【詳　説】  name で指定されたホストの IP アドレスを返す。name が
            xxx.yyy.zzz.www の形式の IP アドレスを表す文字列の場合、その文字列
            を IP アドレスに変換して返す。
            エラーが発生した場合は、大域変数 nserrno にエラー番号がセットされ
            る。
            割り込み禁止状態での呼び出し不可。

-------------------------------------------------------------------------------
【変数名】  int nserrno;

【詳　説】  getipaddress 関数でエラーが発生した場合、その番号がセットされる。

            ENS_BUSY        : 他のファンクションの処理を実行中
            ENS_NOHOST      : ホストが見つからない
            ENS_NORESOURCE  : ハンドル・メモリ不足
            ENS_BADNAME	    : 名前が不適当
            ENS_TIMEOUT	    : タイムアウト

-------------------------------------------------------------------------------



===============================================================================
■　ＴＣＰ　■ (tcp.h)
===============================================================================
【機　能】  能動接続要求

【書　式】  char tcp_activeopen(TCPPRM far *tcpprm);

            TCPPRM far *tcpprm; パラメータテーブルへのポインタ

【戻り値】  エラー   : -1
            正常終了 : ハンドル

【詳　説】  接続先を指定して、接続の確立作業を開始する。接続の完了を待たずに戻
            る。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

            《TCPパラメータテーブル》

            typedef struct {
                void far *rbuf;         /* 受信バッファアドレス */
                uint rbank;             /* 受信バッファバンク */
                uint rbufsize;          /* 受信バッファサイズ(バイト) */
                void far *sbuf;         /* 送信バッファアドレス */
                uint sbank;             /* 送信バッファバンク */
                uint sbufsize;          /* 送信バッファサイズ(バイト) */
                void (huge *notice)();  /* 状態遷移通知関数 */
                WORD thisport;          /* ポート番号 */
                WORD peerport;          /* 接続先ポート番号 */
                char far *host;         /* 接続先ホスト名 */
            } TCPPRM;

            受信バッファ、送信バッファはそれぞれ、TCP が受信、送信に使うバッフ
            ァである。これらのバッファが小さすぎると転送効率が落ちる。受信バッ
            ファは 512 バイト以上用意しなければならない。これらのバッファは
            tcp_close でハンドルを開放するまで維持されなければならない。
            thisportに 0 を指定すると、空いているポートを自動的に割り振る。
            接続先ホストは、ホスト名の名前(例:"host.domain.jp")または IPアドレ
            スを表す文字列(例:"123.45.67.8") で指定する。
            rbank,sbank,notice には常に 0 を指定する。

-------------------------------------------------------------------------------
【機　能】  受動接続要求

【書　式】  char tcp_passiveopen(WORD thisport, void (huge *notice)());

            WORD thisport;         接続を待つポート番号
            void (huge *notice)(); 常に 0 を指定する

【戻り値】  エラー   : -1
            正常終了 : ハンドル

【詳　説】  指定したポートで相手からの接続要求を待つ。相手からの接続要求を待た
            ずに戻る。相手からの接続要求の有無は tcp_state 関数で調べることが
            できる。
            thisportに 0 を指定すると、空いているポートを自動的に割り振る。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

-------------------------------------------------------------------------------
【機　能】  接続要求受理

【書　式】  char tcp_accept(char handle, TCPPRM far *tcpprm);

            char handle;        tcp_passiveopen で得たハンドル
            TCPPRM far *tcpprm; パラメータテーブルへのポインタ

【戻り値】  エラー   : -1
            正常終了 : 新しいハンドル

【詳　説】  tcp_passiveopen で接続要求を待っていたポートに対し接続要求があった
            場合(tcp_state で得られる状態が TCP_WAITACCEPT であるとき)、この関
            数によって接続要求を受理し、接続の確立作業を開始する。接続の完了を
            待たずに戻る。
            正常終了時は、新しいハンドルを返す。接続を要求した相手との接続はこ
            のハンドルによって管理される。handle に指定したハンドル
            (tcp_passiveopen で得たハンドル)で管理されるポートでは別の接続要求
            を待つ。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。
            パラメータテーブルについては tcp_activeopen を参照。ただし、
            notice,thisport,peerport,host は指定する必要はない。

-------------------------------------------------------------------------------
【機　能】  切断要求

【書　式】  char tcp_shutdown(char handle);

            char handle;    ハンドル

【戻り値】  エラー   : -1
            正常終了 :  0

【詳　説】  切断を要求する。相手からの切断要求があるまで実際には切断しないが、
            切断の完了を待たずに戻る。
            この関数の呼び出し後は、tcp_send でデータの送信を行なうことができ
            ない。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

-------------------------------------------------------------------------------
【機　能】  送信

【書　式】  int  tcp_send(char handle, char far *buf, int len, int flag);

            char handle;    ハンドル
            char far *buf;  送信データへのポインタ
            int len;        送信データのバイト数
            int flag;       常に 0

【戻り値】  エラー   : -1
            正常終了 : 送信バッファにコピーできたバイト数

【詳　説】  データを送信する。ただし、送信の完了を待たずに戻る。
            tcp_state で得られる状態が以下の場合のみ送信できる。
              TCP_OPENING,TCP_OPEN,TCP_HISCLOSING
            送信するデータは一旦 TCP 送信バッファ(tcp_activeopen,tcp_accept で
            指定したもの) にコピーされる。送信バッファの空きが少ないときは 
            tcp_send が返す値は len より小さくなる。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

-------------------------------------------------------------------------------
【機　能】  受信

【書　式】  int  tcp_recv(char handle, char far *buf, int len);

            char handle;    ハンドル
            char far *buf;  受信バッファへのポインタ
            int len;        受信バッファのバイト数

【戻り値】  エラー   : -1
            正常終了 : 受信バッファにコピーしたバイト数

【詳　説】  データを受信する。受信データがない場合は 0 を返し、相手からの受信を
            待たずに戻る。
            tcp_state で得られる状態が以下の場合には受信できない。
              TCP_LISTEN,TCP_WAITACCEPT
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

-------------------------------------------------------------------------------
【機　能】  ハンドル開放

【書　式】  char tcp_close(char handle);

            char handle;    ハンドル

【戻り値】  エラー   : -1
            正常終了 :  0

【詳　説】  ハンドルを開放する。接続が完全に切断されていない場合は、強制的に切
            断する。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

-------------------------------------------------------------------------------
【機　能】  接続状態取得

【書　式】  char tcp_state(char handle);

            char handle;    ハンドル

【戻り値】  エラー   : -1
            正常終了 : 接続状態
              TCP_LISTEN     : 相手からの接続要求待ち
              TCP_WAITACCEPT : 接続受理待ち
              TCP_SEARCH     : IP アドレスを検索中
              TCP_OPENING    : 接続処理中
              TCP_OPEN       : 接続が確立している
              TCP_HISCLOSING : 相手から切断要求があり、相手からの受信はもうない
                               (こちらは切断要求を出していない)
              TCP_MYCLOSING  : こちらから切断を要求しこちらからの送信はもうない
                               (相手は切断要求を出していない)
              TCP_CLOSING    : 切断処理中(送受信はもうない)
              TCP_CLOSED     : 完全に切断した

【詳　説】  接続の状態を返す。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

-------------------------------------------------------------------------------
【機　能】  切断原因取得

【書　式】  char tcp_downstate(char handle);

            char handle;    ハンドル

【戻り値】  エラー   : -1
            正常終了 : 切断原因
              TCP_NOTDOWN : まだ切断は開始されていない
              TCP_HISDOWN : 相手から切断が要求された
              TCP_MYDOWN  : こちらが切断を要求した
              TCP_REJECT  : 接続が拒否された
              TCP_TIMEOUT : タイムアウト
              TCP_NOHOST  : 接続先が見つからない

【詳　説】  切断の原因を返す。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

-------------------------------------------------------------------------------
【機　能】  IPアドレス・ポート番号取得

【書　式】  char char tcp_getaddr(char handle, TCPADDR far *addr);

            char handle;       ハンドル
            TCPADDR far *addr; 要素数2個のアドレステーブル配列へのポインタ

【戻り値】  エラー   : -1
            正常終了 :  0

【詳　説】  接続の両端のIPアドレスとポート番号を返す。addr には TCPADDR 型の
            要素数2個の配列へのポインタを指定する。addr[0] にこちら側の、
            addr[1] に相手側の情報が書き出される。
            tcp_state の返す値が TCP_LISTEN (相手からの接続要求待ち)の場合は、
            相手のポート番号・相手のIPアドレス・こちらのIPアドレスが未定義で
            あり正しい値を返さない。また、tcp_state の返す値が TCP_SEARCH 
            (接続先IPアドレスを検索中)の場合は、相手のIPアドレス・こちらのIP
            アドレスが未定義であり正しい値を返さない。
            エラーが発生した場合は、大域変数 tcperrno にエラー番号がセットされ
            る。

            《アドレステーブル》

            typedef struct {
                WORD port;		/* ポート番号 */
                IDWORD ip;		/* IPアドレス */
            } TCPADDR;


-------------------------------------------------------------------------------
【変数名】  int tcperrno;

【詳　説】  TCP 関連関数でエラーが発生した場合、その番号がセットされる。

            ETCP_BUSY       他のファンクションの処理を実行中
            ETCP_BADHANDLE  ハンドル不正
            ETCP_NORESOURCE ハンドル不足
            ETCP_RANGE      アドレス/バンク不正
            ETCP_EXIST      その接続はすでに存在する
            ETCP_CLOSE      すでに切断を開始していて送信・切断できない
            ETCP_BADSTATE   接続要求がないため受理できない、
                            接続を開始していないため送受信できない
            ETCP_BADPORT    ポート番号不正

-------------------------------------------------------------------------------



===============================================================================
■　インジケータ　■ (indicate.h)
===============================================================================
【機　能】  インジケータ表示制御

【書　式】  void indicate_sw(int sw);

	    int sw;         0:表示禁止 1:表示許可

【戻り値】  なし

【詳　説】  テキスト画面ファンクションキー表示行に表示される TEEN の状態表示と
            indicate_char/int/str による表示を制御する。
            常駐時の許可状態は定義ファイル [TSR]104 での指定に従う。

-------------------------------------------------------------------------------
【機　能】  インジケータ文字表示

【書　式】  void indicate_char(int pos, char c);

            int pos;        桁位置(0-79)
            char c;         表示する文字

【戻り値】  なし

【詳　説】  テキスト画面ファンクションキー表示行の指定された桁位置に ASCII 文字
            を表示する。

-------------------------------------------------------------------------------
【機　能】  インジケータ整数表示

【書　式】  void indicate_int(int pos, int len, unsigned val);

            int pos;        桁位置(0-79)
            int len;        表示桁数(1-5)
            unsigned val;   表示する非負整数

【戻り値】  なし

【詳　説】  テキスト画面ファンクションキー表示行の指定された桁位置に非負整数を
            十進表記で指定された表示桁数で表示する。

-------------------------------------------------------------------------------
【機　能】  インジケータ文字列表示

【書　式】  void indicate_str(int pos, char far *str);

            int pos;        桁位置(0-79)
            char far *str;  表示する文字列

【戻り値】  なし

【詳　説】  テキスト画面ファンクションキー表示行の指定された桁位置に ASCII 文字
            列を表示する。2バイトコード文字は表示できない。

-------------------------------------------------------------------------------

============================================================================
■　ＩＰアドレス　■ (inet.h)
============================================================================

□ TEENで用いるIPアドレスの表現形式

    TEENで用いるIPアドレスの表現には以下の３通りがある。

    ・IPアドレス文字列
        IPアドレスをドット表記で表した文字列。例: "192.168.1.2"
    ・IPアドレス構造体
        IPADDR 型のデータ。サイズは 18 バイト。
    ・４バイトIPアドレス
        IPアドレスを 32ビット整数で表したもの。IPアドレス a.b.c.d を次のよう
      に表す。
          MSB 31  24 23  16 15   8 7    0 LSB
              | d  | | c  | | b  | | a  |


    IPアドレス文字列は、TCP/UDPファンクションにおいて接続先・送信先を指定す
  るのに使う。IPアドレス構造体は、接続先・送信先の指定に使うほか、TCP/UDPファ
  ンクションがIPアドレスを返すときに用いられる。(TEEN v0.32 では TCPファンク
  ションでIPアドレス構造体を使うことはできない。)
    ４バイトIPアドレスは、TCP/UDPを使ったアプリケーションで必要な場合にのみ
  用いる。TCP/UDPファンクションでは４バイトIPアドレスを使わない。

    上記３通りのIPアドレスの表現を相互に変換するファンクションとして４つのファ
  ンクション inet_toipaddr,inet_tostr,inet_ipv4addrtoipaddr,inet_toipv4addr
  がある。

    IPアドレス文字列は終端の'\0'を含めて最大で40バイトである(現時点で実際に
  使用しているのは最大16バイトであるが、将来の拡張で40バイトになる可能性があ
  る)。従って、IPアドレス文字列を出力するファンクションを呼び出す時にはIPア
  ドレス文字列の受け取り用に40バイト以上の領域を確保する必要がある。

□ ワイルドカードアドレス

    「どのIPアドレスでも良い」ことを表す特別なIPアドレスをワイルドカードアド
  レスと呼ぶ。「IPアドレスを指定しない」「IPアドレスが未定義である」ことを表
  すのにも使う。
    以下の値をワイルドカードアドレスとして使う。

    ・IPアドレス文字列
        "0.0.0.0"
    ・IPアドレス構造体
        inet_toipaddr(NULL,&ipaddr) で得られる ipaddr の値
    ・４バイトIPアドレス
        0

    与えられたIPアドレスがワイルドカードアドレスかどうかを判定する
  inet_iswildcard が用意されている。

□ ファンクション解説

----------------------------------------------------------------------------
◇ inet_toipaddr        IPアドレス構造体への変換
----------------------------------------------------------------------------

【書式】
                char status = inet_toipaddr(const void far *addr, 
                                                        IPADDR far *ipaddr)

        入力    addr = IPアドレス文字列/IPアドレス構造体へのポインタ
                ipaddr = 変換後のIPアドレス構造体の格納場所へのポインタ

        出力    正常終了時
                        status = 0
                        *ipaddr = IPアドレス構造体
                異常終了時
                        status = -1

【解説】
                  IPアドレス文字列をIPアドレス構造体へ変換する。入力としてIP
                アドレス構造体を与えた場合は、そのままその値を返す。入力が
                IPアドレス文字列でもIPアドレス構造体でもない場合はエラーとな
                る。
                  addr = NULL の場合、ワイルドカードIPアドレスを返す。

【対応版番号】
                v0.32


----------------------------------------------------------------------------
◇ inet_tostr           IPアドレス文字列への変換
----------------------------------------------------------------------------

【書式】
                char status = inet_tostr(const void far *addr, 
                                                        IPADDRSTR far *str)

        入力    addr = IPアドレス文字列/IPアドレス構造体へのポインタ
                ipaddr = 変換後のIPアドレス文字列の格納場所へのポインタ

        出力    正常終了時
                        status = 0
                        *str = IPアドレス文字列
                異常終了時
                        status = -1

【解説】
                  IPアドレス構造体をIPアドレス文字列に変換する。入力としてIP
                アドレス文字列を与えた場合、そこから不要な '0' を取り除いた
                文字列を返す("001.012.123.000" -> "1.12.123.0")。
                  入力が IPアドレス文字列でもIPアドレス構造体でもない場合は
                エラーとなる。

【対応版番号】
                v0.32


----------------------------------------------------------------------------
◇ inet_toipv4addr      ４バイトIPv4アドレスへの変換
----------------------------------------------------------------------------

【書式】
                char status = inet_toipv4addr(const void far *addr, 
                                                        IDWORD far *ipv4addr)
        入力    addr = IPアドレス文字列/IPアドレス構造体のアドレス
                ipv4addr = ４バイトIPv4アドレス格納場所へのポインタ

        出力    正常終了時
                        status = 0
                        *ipv4addr = ４バイトIPv4アドレス
                異常終了時
                        status = -1

【解説】
                  IPアドレス構造体、IPアドレス文字列を４バイトIPv4アドレスに
                変換する。入力がIPアドレス構造体、IPアドレス文字列のいずれで
                もない場合はエラーとなる。
【対応版番号】
                v0.32

----------------------------------------------------------------------------
◇ inet_ipv4addrtoipaddr ４バイトIPv4アドレスからIPアドレス構造体へ変換
----------------------------------------------------------------------------

【書式】
                void inet_ipv4addrtoipaddr(IDWORD ipv4addr, IPADDR far *ipaddr)
        入力    ipv4addr = ４バイトIPv4アドレス
                ipaddr = IPアドレス構造体格納場所へのポインタ

        出力    *ipaddr = IPアドレス構造体

【解説】
                  ４バイトIPv4アドレスをIPアドレス構造体へ変換する。

【対応版番号】
                v0.32


----------------------------------------------------------------------------
◇ inet_iswildcard      ワイルドカードIPアドレスの判定
----------------------------------------------------------------------------

【書式】
                char status = inet_iswildcard(const void far *addr)
        入力    addr = IPアドレス構造体/IPアドレス文字列へのポインタ

        出力    status = 判定
                        0     ワイルドカードでない
                        0以外 ワイルドカードである

【解説】
                  与えた IPアドレス構造体またはIPアドレス文字列がワイルドカ
                ードIPアドレスかどうかを返す。

【対応版番号】
                v0.32


============================================================================
■　ＵＤＰ　■ (udp.h)
============================================================================

□ 一般的な呼び出し手順

    UDP ファンクションの一般的な呼び出し手順は以下の通り。

    ・udp_open でハンドルを取得
    ・udp_sendto で相手を指定して送信 / udp_recvfrom で受信
    ・udp_close でハンドルを解放

    UDPはコネクションなしの通信機能を提供するが、特定の相手との連続した通信
  を容易にするため、通信相手を指定して udp_open を呼び出せる。このような
  udp_open の呼び出しによって得たハンドルを「相手指定付きハンドル」と呼ぶこ
  とにする。相手指定付きハンドルを使った呼び出し手順は以下のようになる。

    ・udp_open で相手を指定してハンドルを取得
    ・udp_state が返すハンドルの状態が UDP_OPEN になるまで待つ
    ・udp_send で送信 / udp_recv で受信
    ・udp_close でハンドルを解放

    udp_send は udp_sendto と異なり送信先を指定する必要がない。udp_recvfrom
  は受信したデータの送信者のIPアドレスとポート番号も返すが、udp_recv はそれ
  らの情報を返さない。

    相手指定付きハンドルと区別するため、相手を指定せずに udp_open を呼び出し
  て得たハンドルを「相手指定なしハンドル」と呼ぶことにする。

□ 送信データの消失

    UDP は送信データが相手に到着することを保証しない。以下の場合は送信データ
  が TEEN 内部で失われることがある。

    ・送信データが大きすぎる場合 (1400バイト以下なら大丈夫なはず)。
    ・UDP以外のものも含め、送信できずにTEEN内部にたまっているデータが多い時。

□ ホスト記述子

    通信相手を指定するのに、以下の３つを使用できる。これらをまとめてホスト記
  述子と呼ぶ。

    ・ホスト名(文字列)
    ・IPアドレス文字列
    ・IPアドレス構造体


□ ファンクション解説

----------------------------------------------------------------------------
◇ udp_open             UDP ハンドルの取得
----------------------------------------------------------------------------

【書式】
                char handle = udp_open(const UDPPRM far *prm)

        入力    prm = UDP パラメータテーブルへのポインタ

                《UDP パラメータテーブル》
                typedef struct {
                    void far *rbuf;         /* 受信バッファアドレス */
                    uint rbank;             /* =0 */
                    uint rbufsize;          /* 受信バッファサイズ(バイト) */
                    void far *sbuf;         /* =0 */
                    uint sbank;             /* =0 */
                    uint sbufsize;          /* =0 */
                    void (huge *callback)();/* =0 */
                    WORD thisport;          /* 自分のポート番号 */
                    WORD peerport;          /* 相手ポート番号 */
                    void far *host;         /* 相手ホスト記述子へのポインタ*/
                    int  callbackid;        /* =0 */
                } UDPPRM;

        出力    正常終了時
                        handle = ハンドル
                異常終了時
                        handle = -1
                        int udperrno = エラーコード
                                EUDP_BUSY        処理中
                                EUDP_NORESOURCE  ハンドル不足
                                EUDP_RANGE       パラメータが不適当
                                EUDP_BADPORT     使用不可能なポート番号を指定

【解説】
                  UDP での送受信に必要なハンドルを取得する。ハンドルの取得に
                あたって、UDP 受信バッファ、自分のポート番号、相手のホスト、
                相手のポート番号を指定する。
                  UDP 受信バッファは、このハンドル宛てに届いた UDP パケット
                を一時的に格納するのに使用される。受信バッファに入り切らなかっ
                たパケットは捨てられる。UDP 受信バッファに指定したメモリ領域
                は、udp_close を呼び出すまで他の用途に使用してはならない。
                  自分のポート番号として UDP_PORTANY (0) を指定した場合、自
                動的にポートが割り当てられる。
                  相手ホスト記述子としてワイルドカードアドレスを指定するか、
                相手ホスト記述子のポインタ(アドレス)として NULL (0) を指定す
                るか、相手ポート番号として UDP_PORTANY (0) を指定した場合、
                返されるハンドルは相手指定なしハンドルとなる。
                  UDP パラメータテーブルは udp_open 実行後は破棄して良い。

【エラーコード】
                EUDP_BADPORT    ポート番号で指定したポートが使用中

                EUDP_RANGE      UDPパラメータテーブル内で指定した値が正しい
                範囲にない。0を与えるべきパラメータに0を与えていない。

                EUDP_NORESOURCE ハンドル不足

【対応版番号】
                v0.30
                IPアドレス構造体,相手指定なしハンドは v0.32 でサポート

----------------------------------------------------------------------------
◇ udp_close            UDP ハンドルの開放
----------------------------------------------------------------------------

【書式】
                char status = udp_close(char handle)

        入力    handle = ハンドル

        出力    正常終了時
                        status = 0
                異常終了時
                        status = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている

【解説】
                  udp_open で取得したハンドルを開放する。

【対応版番号】
                v0.30

----------------------------------------------------------------------------
◇ udp_state            状態取得
----------------------------------------------------------------------------

【書式】
                char state = udp_state(char handle)

        入力    handle = ハンドル

        出力    正常終了時
                        state = 状態
                                UDP_SEARCH  IP アドレス検索中につき送受信不可
                                UDP_OPEN    送受信可能
                                UDP_CLOSED  相手ホストがみつからず送受信不可
                異常終了時
                        state = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている

【解説】
                  現在のハンドルの状態を返す。相手指定なしハンドルでは常に
                UDP_OPEN を返す。

【対応版番号】
                v0.30


----------------------------------------------------------------------------
◇ udp_send             送信
----------------------------------------------------------------------------

【書式】
                int sent = udp_send(char handle, char far *buf, int len)

        入力    handle = ハンドル
                buf = 送信データへのポインタ
                len = 送信データのバイト数

        出力    正常終了時
                        sent = 送信したバイト数
                異常終了時
                        sent = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている
                                EUDP_BADSTATE   送信できる状態にない
                                EUDP_NOPEER     相手が指定されていない
                                EUDP_DATASIZE   データが長すぎて送れない

【解説】
                  データを相手に送信する。一度に送信できるデータのサイズ(UDP
                パケットのサイズ)には上限があり、それを越えた場合はエラーを
                返す。
                  相手指定なしハンドルでは使用できない。

【エラーコード】
                EUDP_BUSY       処理中

                EUDP_BADHANDLE  ハンドルが間違っている

                EUDP_BADSTATE   送信できる状態にない。udp_open で相手ホスト
                記述子としてホスト名を使用し、その IP アドレスがまだ得られて
                いない。

                EUDP_NOPEER     相手が指定されていない。udp_open で相手ホス
                トを指定しなかった。

                EUDP_DATASIZE   データが長すぎて送れない

【バグ】
                  エラーコード EUDP_DATASIZE (16) を返さない。送信データが大
                きすぎる場合は単に捨てられる。

【対応版番号】
                v0.30


----------------------------------------------------------------------------
◇ udp_recv             受信
----------------------------------------------------------------------------

【書式】
                int received = udp_recv(char handle, char far *buf, int len)

        入力    handle = ハンドル
                buf = 受信データ格納場所へのポインタ
                len = 受信データ格納場所のサイズ

        出力    正常終了時
                        received = 受信したバイト数
                異常終了時
                        received = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている
                                EUDP_NODATA     受信データなし
                                EUDP_BUFOVER    受信データが大きすぎる

【解説】
                  受信データを１パケット分取り出し、受信データ格納場所へコピ
                ーする。そのパケットが受信データ格納場所より大きい場合、格納
                場所いっぱいまで受信データをコピーし、入り切らないデータは捨
                て、エラーコード EUDP_BUFOVER (15) を返す。
                  受信したパケットのサイズが 0 の場合は受信したバイト数とし
                て 0 を返す。
                  受信データがない場合はエラーコード EUDP_NODATA を返す。
                  相手指定付きハンドルでは、指定した相手(指定したホストの指
                定したアドレス)から送信されたデータのみを受信する。相手指定
                なしハンドルでは、udp_openで指定した「自分のポート」に送られ
                てくるデータ全てを受信する。

【対応版番号】
                v0.30


----------------------------------------------------------------------------
◇ udp_sendto           宛て先付き送信
----------------------------------------------------------------------------

【書式】
                int sent = 
                        udp_sendto(char handle, const BYTE far *buf, int len,
                                          const void far *toaddr, WORD toport)

        入力    handle = ハンドル
                buf = 送信データへのポインタ
                len = 送信データのバイト数
                toaddr = 送信先IPアドレス文字列またはIPアドレス構造体
                toport = 送信先ポート番号

        出力    正常終了時
                        sent = 送信したバイト数
                異常終了時
                        sent = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている
                                EUDP_BADSTATE   送信先にホスト名を指定した
                                EUDP_DATASIZE   データが長すぎて送れない

【解説】
                  送信データを指定した送信先に送信する。送信先の指定方法とし
                て、IPアドレス文字列とIPアドレス構造体が使える。ホスト名文字
                列を使用した場合はエラーコード EUDP_BADSTATE を返す。
                  一度に送信できるデータのサイズ(UDP パケットのサイズ)には上
                限があり、それを越えた場合はエラーを返す。

【バグ】
                  エラーコード EUDP_DATASIZE (16) を返さない。送信データが大
                きすぎる場合は単に捨てられる。

【対応版番号】
                v0.32


----------------------------------------------------------------------------
◇ udp_recvfrom         送信者情報付き受信
----------------------------------------------------------------------------

【書式】
                int received = 
                        udp_recvfrom(char handle, char far *buf, int len, 
                                  IPADDR far *fromaddr, WORD far *fromport)

        入力    handle = ハンドル
                buf = 受信データ格納領域へのポインタ
                len = 受信データ格納領域のサイズ
                fromaddr = 送信者IPアドレス構造体格納場所へのポインタ
                fromport = 送信者ポート番号格納場所へのポインタ

        出力    正常終了時
                        received = 受信したバイト数
                        *fromaddr = 送信者IPアドレス構造体
                        *fromport = 送信者ポート番号
                異常終了時
                        received = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている
                                EUDP_NODATA     受信データなし
                                EUDP_BUFOVER    受信データが大きすぎる

【解説】
                  受信データを１パケット分取り出し、受信データ格納場所へコピ
                ーすし、その送信者の IP アドレスとポート番号を返す。
                  受信データが受信データ格納領域より大きい場合、格納場所いっ
                ぱいまで受信データをコピーし、入り切らないデータは捨て、エラ
                ーコード EUDP_BUFOVER (15) を返す。
                  受信したパケットのサイズが 0 の場合は受信したバイト数とし
                て 0 を返す。受信データがない場合はエラーコード EUDP_NODATA
                を返す。
                  相手指定付きハンドルでは、指定した相手(指定したホストの指
                定したアドレス)から送信されたデータのみを受信する。相手指定
                なしハンドルでは、udp_openで指定した「自分のポート」に送られ
                てくるデータ全てを受信する。

【対応版番号】
                v0.32


----------------------------------------------------------------------------
◇ udp_getmyaddr        自分のIPアドレス・ポート番号取得
----------------------------------------------------------------------------

【書式】
                char status = udp_getmyaddr(char handle, 
                                        IPADDR far *addr, WORD far *port)

        入力    handle = ハンドル
                addr = IPアドレス構造体格納場所へのポインタ
                port = ポート番号格納場所へのポインタ

        出力    正常終了時
                        status = 0
                        *addr = IPアドレス構造体
                        *port = ポート番号
                異常終了時
                        status = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている

【解説】
                  自分の IPアドレスとポート番号を返す。IPアドレスはIPアドレ
                ス構造体で返す。
                  相手指定なしハンドルでは、IPアドレスとして常にワイルドカー
                ドアドレスを返す。相手指定付きハンドルでは、udp_state の返す
                値が UDP_OPEN の時以外は IPアドレスとしてワイルドカードアド
                レスを返す。

【対応版番号】
                v0.32


----------------------------------------------------------------------------
◇ udp_getpeeraddr      相手のIPアドレス・ポート番号取得
----------------------------------------------------------------------------

【書式】
                char status = udp_getpeeraddr(char handle, 
                                        IPADDR far *addr, WORD far *port)

        入力    handle = ハンドル
                addr = IPアドレス構造体格納場所へのポインタ
                port = ポート番号格納場所へのポインタ

        出力    正常終了時
                        status = 0
                        *addr = IPアドレス構造体
                        *port = ポート番号
                異常終了時
                        status = -1
                        int udperrno = エラーコード
                                EUDP_BUSY       処理中
                                EUDP_BADHANDLE  ハンドルが間違っている

【解説】
                  相手の IPアドレスとポート番号を返す。IPアドレスはIPアドレ
                ス構造体で返す。
                  相手指定なしハンドルでは、IP アドレスとしてワイルドカード
                アドレスを、ポート番号として UDP_PORTANY (0) を返す。相手指
                定付きハンドルでは、udp_state の返す値が UDP_OPEN の時のみ正
                しい値を返す。

【対応版番号】
                v0.32


============================================================================
■　ＩＰ／ＩＣＭＰ　■ (ip.h)
============================================================================

□ ファンクション解説

----------------------------------------------------------------------------
◇ ip_getrtentry        ルーティングテーブルエントリ取得
----------------------------------------------------------------------------

【書式】
                char status = 
                        ip_getrtentry(int n, void far *buf, uint bufsize);

        入力    n = エントリの番号(>=0)
                buf = ルーティングテーブルエントリ格納場所へのポインタ
                bufsize = ルーティングテーブルエントリ格納場所のバイト数

        出力    正常終了時
                        status = 0
                        *buf = ルーティングテーブルエントリ
                異常終了時
                        status = -1 (n がエントリ番号の最大を越えている)

                《ルーティングテーブルエントリ》
                typedef struct {
                    IPADDR dest;           /* 宛て先ホスト/ネットアドレス */
                    uchar  destmask;       /* dest のネットマスクのビット数 */
                    IPADDR gateway;        /* ゲートウェイのアドレス */
                    struct {
                        int valid:1;       /* このエントリは有効 */
                        int gateway:1;     /* indirectルート */
                        int reserved:14;   /* (予約) */
                    } flag;
                    uchar interface;       /* ネットワークインタフェース番号 */
                } RTENTRY;

【解説】
                  ルーティングテーブル中の各エントリを返す。各エントリには 0
                から順に番号が付いている。n に取得するエントリの番号を指定す
                るが、これがエントリ数以上である場合は status = -1 を返す。
                  通常、buf で指定する格納場所は RTENTRY 構造体と同じサイズ
                だけ用意し、bufsize にそのバイト数を指定する。bufsize が
                RTENTRY 構造体のサイズより小さい場合は、入りきらない部分は
                buf に格納されない。(bufsize の指定が必要なのは、将来のバー
                ジョンで RTENTRY のサイズが増えた場合でも古いバージョン用の
                プログラムがそのまま動くようにするため。)
                  以下、RTENTRY構造体について説明する。
                  dest は宛て先のホストまたはネットワークのアドレス(IPアドレ
                ス構造体)である。これがワイルドカードアドレス(0.0.0.0)である
                場合、そのエントリはデフォルトルートである。
                  destmask は dest に適用するネットマスクを、1のビット数で示
                したものである。デフォルトルートでは0、ホストルートでは32で
                あり、それ以外はネットワークルートである。
                  gateway はゲートウェイのアドレス(IPアドレス構造体)である。
                flag.gateway=1 の時のみ意味を持つ。
                  flag.valid が1ならそのエントリが有効であることを示す。
                  flag.gateway が1ならそのエントリがindirect(間接)ルートであ
                り、宛て先に到達するのにゲートウェイを利用することを示す。
                  interface は dest 宛のパケットを送信する際に使用するネット
                ワークインタフェースの番号である。この番号は現在はつねに0で
                ある(ネットワークインタフェースが1個しかないため)。

【対応版番号】
                v0.36


----------------------------------------------------------------------------
◇ icmp_send            ICMPメッセージ送信
----------------------------------------------------------------------------

【書式】
                char status = icmp_send(const ICMPPRM far *icmpprm);

        入力    icmpprm = ICMPパラメータテーブルへのポインタ

                《ICMPパラメータテーブル》
                typedef struct {
                    void far *src;      /* 常にNULL(0)を指定 */
                    void far *dest;     /* ICMPメッセージ送信先:IPアドレス文
                                           字列または構造体へのポインタ */
                    uchar ttl;          /* TTL(Time To Live) */
                    uchar dmy;          /* 常に 0 を指定 (未使用) */
                    uchar type;         /* ICMPタイプ */
                    uchar code;         /* ICMPコード */
                    uint id;            /* ICMPメッセージ識別番号 */
                    uint seq;           /* ICMPメッセージシーケンス番号 */
                    void far *buf;      /* ICMPオプションデータへのポインタ */
                    uint len;           /* ICMPオプションデータ長(バイト) */
                } ICMPPRM;

        出力    正常終了時
                        status = 0
                異常終了時
                        status = -1

【解説】
                  ICMPメッセージを宛て先destに送信する。ICMPメッセージタイプ、
                コード、識別番号、シーケンス番号、オプションデータを指定する。
                IPパケットに設定するTTL(Time To Live)も指定する。
                  宛て先は、IPアドレス文字列またはIPアドレス構造体で指定し、
                destにはその文字列または構造体へのポインタを与える。ホスト名
                を指定するとエラーになる。
                  ttl には TTL を 1〜255 で指定する。
                  type および code にはそれぞれICMPメッセージタイプとコード
                を指定する。
                  id と seq にはそれぞれICMPメッセージの識別番号とシーケンス
                番号を指定する。id と seq の値は、ICMPメッセージの 4 バイト
                目(WORD)と 6バイト目(WORD)に書き込まれる。ICMPメッセージタイ
                プによっては識別番号とシーケンス番号が不要であるが、その場合
                は id,seq に0を指定することにより、4〜7バイト目に 0 が書き込
                まれる。
                  ICMPメッセージの8バイト目以降にデータを書き込む場合には、
                そのデータへのポインタをbufに、データの長さ(バイト)をlenに指
                定する。不要な場合はbuf,lenに0を指定する。
                  src および dmy には常に0を与える。

                  このファンクションはIPv6移行時の問題が考慮されていない。
                ping, traceroute等の特殊なアプリケーションをのぞき、一般アプ
                リケーションではなるべく使用しないで頂きたい。

【対応版番号】
                v0.37


----------------------------------------------------------------------------
◇ icmp_recv            ICMPメッセージ受信
----------------------------------------------------------------------------

【書式】
                int status = icmp_recv(ICMPPRM far *icmpprm);

        入力    icmpprm = ICMPパラメータテーブルへのポインタ

                《ICMPパラメータテーブル》
                typedef struct {
                    void far *src;      /* ICMPメッセージ送信元IPアドレス */
                    void far *dest;     /* ICMPメッセージ送信先IPアドレス */
                    uchar ttl;          /* TTL(Time To Live) (出力) */
                    uchar dmy;          /* 未使用 */
                    uchar type;         /* ICMPタイプ (出力) */
                    uchar code;         /* ICMPコード (出力) */
                    uint id;            /* ICMPメッセージ識別番号 (出力) */
                    uint seq;           /* ICMPメッセージシーケンス番号 
                                           (出力) */
                    void far *buf;      /* ICMPオプションデータ格納場所への
                                           ポインタ */
                    uint len;           /* ICMPオプションデータ格納場所サイズ
                                           (バイト) (入出力) */
                } ICMPPRM;

        出力    正常終了時
                        status = オプションデータ格納場所に得られた
                                 データの長さ(バイト)
                        ICMPパラメータテーブル
                                ttl  = 受信メッセージのTTL
                                type = 受信メッセージのタイプ
                                code = 受信メッセージのコード
                                id   = 受信メッセージの識別番号
                                seq  = 受信メッセージのシーケンス番号
                                len  = オプションデータ格納場所に得られた
                                       データの長さ(バイト)
                        srcで指定したIPアドレス構造体 = 
                                        メッセージ送信元IPアドレス
                        destで指定したIPアドレス構造体 = 
                                        メッセージ送信先IPアドレス
                        bufで指定したオプションデータ格納場所 =
                                        オプションデータ
                異常終了時
                        status = -1

【解説】
                  最後に受信したICMPメッセージを取得する。このファンクション
                を実行すると、受信したメッセージはTEEN内部から消去される。最
                後にこのファンクションを実行してから受信したメッセージがない
                場合、エラーになる。
                  src, dest にはそれぞれメッセージの送信元と送信先のIPアドレ
                スを保存するIPアドレス構造体へのポインタを指定する。IPアドレ
                ス構造体は初期化されていなくてよい。IPアドレスを取得する必要
                のない場合はNULLを指定する。
                  buf にはオプションデータの格納場所へのポインタを、len には
                その格納場所のサイズ(バイト)を指定する。オプションデータを取
                得する必要のない場合、bufにNULLを、lenに0を指定する。ここで
                オプションデータとは、ICMPメッセージの8バイト目以降(識別番号、
                シーケンス番号の後)に格納されているデータである。
                  入力として与えるICMPパラメータテーブルのうち、
                ttl,dmy,type,code,id,seqには値を指定しなくてよい。
                  正常終了した場合、ttl,type,code,id,seq にそれぞれ対応する
                値が入る。オプションデータ格納場所に得られたデータ長がlenに
                入る。

                  このファンクションによって取得された受信メッセージはすぐに
                TEEN内部から消去されるため、複数のアプリケーションがこのファ
                ンクションを使用する場合、各受信メッセージはいずれか一つのア
                プリケーションでしか取得できない。

                  このファンクションはIPv6移行時の問題が考慮されていない。
                ping, traceroute等の特殊なアプリケーションをのぞき、一般アプ
                リケーションではなるべく使用しないで頂きたい。

【対応版番号】
                v0.37
                v0.38 より TTLが取得可能

